/**
 * shaders_embedded.c
 *
 * Embedded GLSL shaders for the MVP renderer.
 * All shaders are GLSL 330 core compatible.
 */

// ============================================================================
// PBR VERTEX SHADER
// ============================================================================
const char* SHADER_PBR_VERT =
"#version 330 core\n"
"\n"
"// Vertex attributes\n"
"layout(location = 0) in vec3 aPosition;\n"
"layout(location = 1) in vec3 aNormal;\n"
"layout(location = 2) in vec2 aTexCoord;\n"
"\n"
"// Output to fragment shader\n"
"out vec3 FragPos;              // Fragment position in world space\n"
"out vec3 Normal;               // Normal in world space\n"
"out vec2 TexCoord;             // Texture coordinates\n"
"out vec4 FragPosLightSpace;    // Fragment position in light space (for shadows)\n"
"\n"
"// Transformation matrices\n"
"uniform mat4 uModel;           // Model matrix (object -> world)\n"
"uniform mat4 uView;            // View matrix (world -> camera)\n"
"uniform mat4 uProjection;      // Projection matrix (camera -> clip)\n"
"uniform mat4 uLightSpaceMatrix; // Light's view-projection matrix\n"
"\n"
"void main()\n"
"{\n"
"    // Transform vertex position to world space\n"
"    vec4 worldPos = uModel * vec4(aPosition, 1.0);\n"
"    FragPos = worldPos.xyz;\n"
"    \n"
"    // Transform normal to world space (using normal matrix to handle non-uniform scaling)\n"
"    // Note: For proper normal transformation, should use transpose(inverse(mat3(uModel)))\n"
"    // but for performance we assume uniform scaling here\n"
"    Normal = mat3(uModel) * aNormal;\n"
"    \n"
"    // Pass through texture coordinates\n"
"    TexCoord = aTexCoord;\n"
"    \n"
"    // Transform position to light space for shadow mapping\n"
"    FragPosLightSpace = uLightSpaceMatrix * worldPos;\n"
"    \n"
"    // Transform to clip space (final position)\n"
"    gl_Position = uProjection * uView * worldPos;\n"
"}\n";

// ============================================================================
// PBR FRAGMENT SHADER - Cook-Torrance BRDF
// ============================================================================
const char* SHADER_PBR_FRAG =
"#version 330 core\n"
"\n"
"// Input from vertex shader\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"in vec2 TexCoord;\n"
"in vec4 FragPosLightSpace;\n"
"\n"
"// Output color\n"
"out vec4 FragColor;\n"
"\n"
"// Material properties (PBR parameters)\n"
"uniform vec3 uAlbedo;          // Base color (diffuse reflectance)\n"
"uniform float uMetallic;       // Metallic property [0=dielectric, 1=metal]\n"
"uniform float uRoughness;      // Surface roughness [0=smooth, 1=rough]\n"
"uniform float uAO;             // Ambient occlusion [0=fully occluded, 1=no occlusion]\n"
"\n"
"// Lighting\n"
"uniform vec3 uViewPos;         // Camera position\n"
"uniform vec3 uLightDir;        // Directional light direction\n"
"uniform vec3 uLightColor;      // Light color and intensity\n"
"\n"
"// Shadow mapping\n"
"uniform sampler2D uShadowMap;  // Shadow depth map\n"
"\n"
"const float PI = 3.14159265359;\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// GGX/Trowbridge-Reitz Normal Distribution Function (NDF)\n"
"// Describes the distribution of microfacet normals\n"
"// Higher roughness = wider distribution of microfacet orientations\n"
"// ----------------------------------------------------------------------------\n"
"float DistributionGGX(vec3 N, vec3 H, float roughness)\n"
"{\n"
"    float a = roughness * roughness;       // Disney remapping: roughness -> alpha\n"
"    float a2 = a * a;\n"
"    float NdotH = max(dot(N, H), 0.0);\n"
"    float NdotH2 = NdotH * NdotH;\n"
"    \n"
"    float nom = a2;\n"
"    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n"
"    denom = PI * denom * denom;\n"
"    \n"
"    return nom / denom;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Schlick-GGX Geometry Function (single direction)\n"
"// Models shadowing and masking of microfacets\n"
"// ----------------------------------------------------------------------------\n"
"float GeometrySchlickGGX(float NdotV, float roughness)\n"
"{\n"
"    float r = (roughness + 1.0);\n"
"    float k = (r * r) / 8.0;               // Direct lighting remapping\n"
"    \n"
"    float nom = NdotV;\n"
"    float denom = NdotV * (1.0 - k) + k;\n"
"    \n"
"    return nom / denom;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Smith's method - combines geometry shadowing and masking\n"
"// Accounts for both view direction and light direction obstruction\n"
"// ----------------------------------------------------------------------------\n"
"float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n"
"{\n"
"    float NdotV = max(dot(N, V), 0.0);\n"
"    float NdotL = max(dot(N, L), 0.0);\n"
"    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n"
"    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n"
"    \n"
"    return ggx1 * ggx2;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Fresnel-Schlick approximation\n"
"// Describes the ratio of reflected vs. refracted light at surface\n"
"// F0 is the base reflectivity at zero incidence (perpendicular view)\n"
"// ----------------------------------------------------------------------------\n"
"vec3 FresnelSchlick(float cosTheta, vec3 F0)\n"
"{\n"
"    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// PCF (Percentage Closer Filtering) shadow sampling\n"
"// Samples 3x3 grid around fragment for soft shadow edges\n"
"// Returns: 0.0 = fully shadowed, 1.0 = fully lit\n"
"// ----------------------------------------------------------------------------\n"
"float ShadowCalculation(vec4 fragPosLightSpace, vec3 normal, vec3 lightDir)\n"
"{\n"
"    // Perform perspective divide\n"
"    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n"
"    \n"
"    // Transform to [0,1] range (from NDC [-1,1])\n"
"    projCoords = projCoords * 0.5 + 0.5;\n"
"    \n"
"    // Outside shadow map frustum = no shadow\n"
"    if(projCoords.z > 1.0)\n"
"        return 1.0;\n"
"    \n"
"    // Get closest depth value from light's perspective\n"
"    float closestDepth = texture(uShadowMap, projCoords.xy).r;\n"
"    \n"
"    // Get depth of current fragment from light's perspective\n"
"    float currentDepth = projCoords.z;\n"
"    \n"
"    // Bias to prevent shadow acne (self-shadowing artifacts)\n"
"    // Adaptive bias based on surface angle to light\n"
"    float bias = max(0.005 * (1.0 - dot(normal, lightDir)), 0.0005);\n"
"    \n"
"    // PCF: Sample 3x3 grid for soft shadows\n"
"    float shadow = 0.0;\n"
"    vec2 texelSize = 1.0 / textureSize(uShadowMap, 0);\n"
"    for(int x = -1; x <= 1; ++x)\n"
"    {\n"
"        for(int y = -1; y <= 1; ++y)\n"
"        {\n"
"            float pcfDepth = texture(uShadowMap, projCoords.xy + vec2(x, y) * texelSize).r;\n"
"            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;\n"
"        }\n"
"    }\n"
"    shadow /= 9.0;  // Average of 9 samples\n"
"    \n"
"    return 1.0 - shadow;  // Return light amount (not shadow amount)\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Main PBR lighting calculation\n"
"// ----------------------------------------------------------------------------\n"
"void main()\n"
"{\n"
"    // Normalize inputs\n"
"    vec3 N = normalize(Normal);\n"
"    vec3 V = normalize(uViewPos - FragPos);\n"
"    \n"
"    // Calculate F0 (base reflectivity)\n"
"    // Dielectrics have ~4% reflectivity, metals use albedo as F0\n"
"    vec3 F0 = vec3(0.04);\n"
"    F0 = mix(F0, uAlbedo, uMetallic);\n"
"    \n"
    // Reflectance equation (single directional light)

"    vec3 Lo = vec3(0.0);\n"
"    \n"
"    // Light calculations\n"
"    vec3 L = normalize(-uLightDir); // Directional light comes from uLightDir\n"
"    vec3 H = normalize(V + L);  // Halfway vector\n"
"\n"
"\n"
"    vec3 radiance = uLightColor;\n"
"    \n"
"    // Cook-Torrance BRDF components\n"
"    float NDF = DistributionGGX(N, H, uRoughness);\n"
"    float G = GeometrySmith(N, V, L, uRoughness);\n"
"    vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);\n"
"    \n"
"    // Specular contribution (Cook-Torrance)\n"
"    vec3 numerator = NDF * G * F;\n"
"    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001; // Prevent divide by zero\n"
"    vec3 specular = numerator / denominator;\n"
"    \n"
"    // Energy conservation: kS + kD = 1.0\n"
"    vec3 kS = F;  // Specular reflection coefficient\n"
"    vec3 kD = vec3(1.0) - kS;  // Diffuse reflection coefficient\n"
"    kD *= 1.0 - uMetallic;  // Metals have no diffuse reflection\n"
"    \n"
"    // Lambertian diffuse\n"
"    float NdotL = max(dot(N, L), 0.0);\n"
"    \n"
"    // Shadow calculation\n"
"    float shadow = ShadowCalculation(FragPosLightSpace, N, L);\n"
"    \n"
"    // Combine diffuse + specular with shadow\n"
"    Lo += (kD * uAlbedo / PI + specular) * radiance * NdotL * shadow;\n"
"    \n"
"    // Ambient lighting (crude approximation using AO)\n"
"    vec3 ambient = vec3(0.03) * uAlbedo * uAO;\n"
"    \n"
"    // Final color\n"
"    vec3 color = ambient + Lo;\n"
"    \n"
"    // Output linear color (tone mapping done in post-process)\n"
"    FragColor = vec4(color, 1.0);\n"
"}\n";

// ============================================================================
// SHADOW VERTEX SHADER
// ============================================================================
const char* SHADER_SHADOW_VERT =
"#version 330 core\n"
"\n"
"// Vertex position\n"
"layout(location = 0) in vec3 aPosition;\n"
"\n"
"// Light space transformation\n"
"uniform mat4 uLightSpaceMatrix;  // Light's view-projection matrix\n"
"uniform mat4 uModel;              // Model matrix\n"
"\n"
"void main()\n"
"{\n"
"    // Transform vertex to light's clip space\n"
"    // Depth is written automatically to the depth buffer\n"
"    gl_Position = uLightSpaceMatrix * uModel * vec4(aPosition, 1.0);\n"
"}\n";

// ============================================================================
// SHADOW FRAGMENT SHADER
// ============================================================================
const char* SHADER_SHADOW_FRAG =
"#version 330 core\n"
"\n"
"// No output needed - depth is written automatically\n"
"// This shader intentionally left minimal for depth-only rendering\n"
"\n"
"void main()\n"
"{\n"
"    // Fragment depth is written to gl_FragDepth automatically\n"
"    // No color output needed for shadow map generation\n"
"}\n";

// ============================================================================
// FULLSCREEN QUAD VERTEX SHADER
// ============================================================================
const char* SHADER_QUAD_VERT =
"#version 330 core\n"
"\n"
"// Vertex attributes for fullscreen quad\n"
"layout(location = 0) in vec2 aPosition;  // [-1,1] NDC coordinates\n"
"layout(location = 1) in vec2 aTexCoord;  // [0,1] UV coordinates\n"
"\n"
"// Output to fragment shader\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"    // Pass through position (already in NDC space)\n"
"    gl_Position = vec4(aPosition, 0.0, 1.0);\n"
"    \n"
"    // Pass through texture coordinates\n"
"    TexCoord = aTexCoord;\n"
"}\n";

// ============================================================================
// SSAO FRAGMENT SHADER - Ultra-Lite 8-Sample Depth-Based AO
// ============================================================================
const char* SHADER_SSAO_FRAG =
"#version 330 core\n"
"\n"
"in vec2 TexCoord;\n"
"out float FragColor;  // Single-channel AO value\n"
"\n"
"uniform sampler2D uDepthTexture;      // Scene depth buffer\n"
"uniform sampler2D uNoiseTexture;      // 4x4 random rotation vectors\n"
"uniform vec3 uSamples[8];             // Hemisphere sample kernel\n"
"uniform mat4 uProjection;             // Camera projection matrix\n"
"uniform mat4 uView;                   // Camera view matrix\n"
"uniform vec2 uNoiseScale;             // Screen size / 4 (for tiling noise)\n"
"uniform float uRadius;                // Sample radius (default: 0.5)\n"
"uniform float uBias;                  // Depth bias (default: 0.025)\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Reconstruct view-space position from depth\n"
"// ----------------------------------------------------------------------------\n"
"vec3 ReconstructViewPos(vec2 uv, float depth)\n"
"{\n"
"    // Convert depth [0,1] to NDC [-1,1]\n"
"    vec4 clipSpacePos = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);\n"
"    \n"
"    // Inverse projection\n"
"    vec4 viewSpacePos = inverse(uProjection) * clipSpacePos;\n"
"    \n"
"    // Perspective division\n"
"    return viewSpacePos.xyz / viewSpacePos.w;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Estimate screen-space normal from depth gradients\n"
"// ----------------------------------------------------------------------------\n"
"vec3 EstimateNormal(vec2 uv, vec3 viewPos)\n"
"{\n"
"    vec2 texelSize = 1.0 / textureSize(uDepthTexture, 0);\n"
"    \n"
"    // Sample neighboring depths\n"
"    float depthRight = texture(uDepthTexture, uv + vec2(texelSize.x, 0.0)).r;\n"
"    float depthUp = texture(uDepthTexture, uv + vec2(0.0, texelSize.y)).r;\n"
"    \n"
"    // Reconstruct neighboring positions\n"
"    vec3 posRight = ReconstructViewPos(uv + vec2(texelSize.x, 0.0), depthRight);\n"
"    vec3 posUp = ReconstructViewPos(uv + vec2(0.0, texelSize.y), depthUp);\n"
"    \n"
"    // Cross product for normal\n"
"    vec3 dx = posRight - viewPos;\n"
"    vec3 dy = posUp - viewPos;\n"
"    \n"
"    return normalize(cross(dx, dy));\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Main SSAO calculation\n"
"// ----------------------------------------------------------------------------\n"
"void main()\n"
"{\n"
"    // Sample depth at current fragment\n"
"    float depth = texture(uDepthTexture, TexCoord).r;\n"
"    \n"
"    // Skip skybox/far plane (depth = 1.0)\n"
"    if (depth >= 0.9999) {\n"
"        FragColor = 1.0;  // No occlusion for sky\n"
"        return;\n"
"    }\n"
"    \n"
"    // Reconstruct view-space position and normal\n"
"    vec3 fragPos = ReconstructViewPos(TexCoord, depth);\n"
"    vec3 normal = EstimateNormal(TexCoord, fragPos);\n"
"    \n"
"    // Sample random rotation vector from tiled noise texture\n"
"    vec3 randomVec = texture(uNoiseTexture, TexCoord * uNoiseScale).xyz;\n"
"    \n"
"    // Create TBN matrix (tangent-space to view-space)\n"
"    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n"
"    vec3 bitangent = cross(normal, tangent);\n"
"    mat3 TBN = mat3(tangent, bitangent, normal);\n"
"    \n"
"    // Accumulate occlusion from 8 samples\n"
"    float occlusion = 0.0;\n"
"    for (int i = 0; i < 8; ++i)\n"
"    {\n"
"        // Transform sample from tangent-space to view-space\n"
"        vec3 samplePos = TBN * uSamples[i];\n"
"        samplePos = fragPos + samplePos * uRadius;\n"
"        \n"
"        // Project sample to screen space\n"
"        vec4 offset = vec4(samplePos, 1.0);\n"
"        offset = uProjection * offset;\n"
"        offset.xyz /= offset.w;\n"
"        offset.xyz = offset.xyz * 0.5 + 0.5;  // [-1,1] -> [0,1]\n"
"        \n"
"        // Sample depth at projected position\n"
"        float sampleDepth = texture(uDepthTexture, offset.xy).r;\n"
"        vec3 sampleViewPos = ReconstructViewPos(offset.xy, sampleDepth);\n"
"        \n"
"        // Range check: only occlude if sample is within radius\n"
"        float rangeCheck = smoothstep(0.0, 1.0, uRadius / abs(fragPos.z - sampleViewPos.z));\n"
"        \n"
"        // Accumulate occlusion (with bias to prevent self-shadowing)\n"
"        occlusion += (sampleViewPos.z >= samplePos.z + uBias ? 1.0 : 0.0) * rangeCheck;\n"
"    }\n"
"    \n"
"    // Average and invert (1.0 = no occlusion, 0.0 = full occlusion)\n"
"    occlusion = 1.0 - (occlusion / 8.0);\n"
"    \n"
"    // Output AO factor\n"
"    FragColor = occlusion;\n"
"}\n";

// ============================================================================
// SSAO COMPOSITE FRAGMENT SHADER - Apply AO to Scene
// ============================================================================
const char* SHADER_SSAO_COMPOSITE_FRAG =
"#version 330 core\n"
"\n"
"in vec2 TexCoord;\n"
"out vec4 FragColor;\n"
"\n"
"uniform sampler2D uSceneTexture;  // Scene color\n"
"uniform sampler2D uSSAOTexture;   // AO factor [0,1]\n"
"uniform float uSSAOStrength;      // AO intensity (default: 1.0)\n"
"\n"
"void main()\n"
"{\n"
"    // Sample scene color and AO factor\n"
"    vec3 color = texture(uSceneTexture, TexCoord).rgb;\n"
"    float ao = texture(uSSAOTexture, TexCoord).r;\n"
"    \n"
"    // Apply AO with strength control\n"
"    // Lerp between full color (ao=1.0) and darkened color (ao=0.0)\n"
"    ao = mix(1.0, ao, uSSAOStrength);\n"
"    \n"
"    // Multiply scene color by AO factor\n"
"    FragColor = vec4(color * ao, 1.0);\n"
"}\n";

// ============================================================================
// POST-PROCESS FRAGMENT SHADER (FXAA + Tone Mapping + Gamma Correction)
// ============================================================================
const char* SHADER_POSTPROCESS_FRAG =
"#version 330 core\n"
"\n"
"in vec2 TexCoord;\n"
"out vec4 FragColor;\n"
"\n"
"uniform sampler2D uSceneTexture;  // HDR scene color\n"
"uniform float uExposure;          // Exposure for tone mapping (default: 1.0)\n"
"\n"
"// FXAA configuration\n"
"const float FXAA_SPAN_MAX = 8.0;\n"
"const float FXAA_REDUCE_MUL = 1.0 / 8.0;\n"
"const float FXAA_REDUCE_MIN = 1.0 / 128.0;\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Simplified FXAA (Fast Approximate Anti-Aliasing)\n"
"// Detects edges using luminance and applies directional blur\n"
"// ----------------------------------------------------------------------------\n"
"vec3 FXAA(sampler2D tex, vec2 uv)\n"
"{\n"
"    vec2 texelSize = 1.0 / textureSize(tex, 0);\n"
"    \n"
"    // Sample 5 points: center + 4 corners of a cross pattern\n"
"    vec3 rgbNW = texture(tex, uv + vec2(-1.0, -1.0) * texelSize).rgb;\n"
"    vec3 rgbNE = texture(tex, uv + vec2( 1.0, -1.0) * texelSize).rgb;\n"
"    vec3 rgbSW = texture(tex, uv + vec2(-1.0,  1.0) * texelSize).rgb;\n"
"    vec3 rgbSE = texture(tex, uv + vec2( 1.0,  1.0) * texelSize).rgb;\n"
"    vec3 rgbM  = texture(tex, uv).rgb;\n"
"    \n"
"    // Convert to luminance (perceived brightness)\n"
"    // Using Rec. 709 luma coefficients\n"
"    const vec3 luma = vec3(0.299, 0.587, 0.114);\n"
"    float lumaNW = dot(rgbNW, luma);\n"
"    float lumaNE = dot(rgbNE, luma);\n"
"    float lumaSW = dot(rgbSW, luma);\n"
"    float lumaSE = dot(rgbSE, luma);\n"
"    float lumaM  = dot(rgbM, luma);\n"
"    \n"
"    // Find min/max luminance for edge detection\n"
"    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
"    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
"    \n"
"    // Calculate edge direction (gradient)\n"
"    vec2 dir;\n"
"    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
"    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
"    \n"
"    // Normalize direction, scaled by edge strength\n"
"    float dirReduce = max(\n"
"        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n"
"        FXAA_REDUCE_MIN);\n"
"    \n"
"    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
"    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) * texelSize;\n"
"    \n"
"    // Sample along edge direction\n"
"    vec3 rgbA = 0.5 * (\n"
"        texture(tex, uv + dir * (1.0/3.0 - 0.5)).rgb +\n"
"        texture(tex, uv + dir * (2.0/3.0 - 0.5)).rgb);\n"
"    \n"
"    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n"
"        texture(tex, uv + dir * -0.5).rgb +\n"
"        texture(tex, uv + dir *  0.5).rgb);\n"
"    \n"
"    float lumaB = dot(rgbB, luma);\n"
"    \n"
"    // Choose blend based on whether we're on an edge\n"
"    if((lumaB < lumaMin) || (lumaB > lumaMax))\n"
"        return rgbA;\n"
"    else\n"
"        return rgbB;\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Reinhard tone mapping operator\n"
"// Maps HDR [0, infinity] to LDR [0, 1]\n"
"// Simple and efficient, preserves color ratios\n"
"// ----------------------------------------------------------------------------\n"
"vec3 ReinhardToneMapping(vec3 color)\n"
"{\n"
"    return color / (color + vec3(1.0));\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Gamma correction: Linear to sRGB\n"
"// Human perception is non-linear, monitors expect sRGB\n"
"// ----------------------------------------------------------------------------\n"
"vec3 GammaCorrection(vec3 color)\n"
"{\n"
"    const float gamma = 2.2;\n"
"    return pow(color, vec3(1.0 / gamma));\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// Main post-processing pipeline\n"
"// ----------------------------------------------------------------------------\n"
"void main()\n"
"{\n"
"    // Step 1: FXAA anti-aliasing\n"
"    vec3 color = FXAA(uSceneTexture, TexCoord);\n"
"    \n"
"    // Step 2: Exposure adjustment\n"
"    color *= uExposure;\n"
"    \n"
"    // Step 3: Tone mapping (HDR -> LDR)\n"
"    color = ReinhardToneMapping(color);\n"
"    \n"
"    // Step 4: Gamma correction (Linear -> sRGB)\n"
"    color = GammaCorrection(color);\n"
"    \n"
"    // Output final LDR color\n"
"    FragColor = vec4(color, 1.0);\n"
"}\n";
