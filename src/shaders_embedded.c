// shaders_embedded.c
// This file contains embedded shader source code strings.

const char* SHADER_PBR_VERT =
    "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "layout (location = 1) in vec3 aNormal;\n"
    "layout (location = 2) in vec2 aTexCoords;\n"
    "layout (location = 3) in vec3 aTangent;\n"
    "\n"
    "out VS_OUT {\n"
    "    vec3 FragPos;\n"
    "    vec3 Normal;\n"
    "    vec2 TexCoords;\n"
    "} vs_out;\n"
    "\n"
    "uniform mat4 uProjection;\n"
    "uniform mat4 uView;\n"
    "uniform mat4 uModel;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    vs_out.FragPos = vec3(uModel * vec4(aPos, 1.0));\n"
    "    vs_out.Normal = mat3(transpose(inverse(uModel))) * aNormal;\n"
    "    vs_out.TexCoords = aTexCoords;\n"
    "    gl_Position = uProjection * uView * uModel * vec4(aPos, 1.0);\n"
    "}\n";

const char* SHADER_PBR_FRAG =
    "#version 330 core\n"
    "out vec4 FragColor;\n"
    "\n"
    "in VS_OUT {\n"
    "    vec3 FragPos;\n"
    "    vec3 Normal;\n"
    "    vec2 TexCoords;\n"
    "} fs_in;\n"
    "\n"
    "uniform vec3 uViewPos;\n"
    "\n"
    "// Material parameters\n"
    "uniform vec3 uAlbedo;\n"
    "uniform float uMetallic;\n"
    "uniform float uRoughness;\n"
    "uniform float uAO;\n"
    "\n"
    "// Light parameters (single directional light for MVP)\n"
    "uniform vec3 uLightDir;\n"
    "uniform vec3 uLightColor;\n"
    "\n"
    "// Shadow mapping\n"
    "uniform sampler2D uShadowMap;\n"
    "uniform mat4 uLightSpaceMatrix;\n"
    "\n"
    "// Constants\n"
    "const float PI = 3.14159265359;\n"
    "\n"
    "// --- PBR functions ---\n"
    "vec3 getNormal() {\n"
    "    return normalize(fs_in.Normal);\n"
    "}\n"
    "\n"
    "vec3 fresnelSchlick(float cosTheta, vec3 F0) {\n"
    "    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n"
    "}\n"
    "\n"
    "float DistributionGGX(vec3 N, vec3 H, float roughness) {\n"
    "    float a = roughness*roughness;\n"
    "    float a2 = a*a;\n"
    "    float NdotH = max(dot(N, H), 0.0);\n"
    "    float NdotH2 = NdotH*NdotH;\n"
    "\n"
    "    float nom   = a2;\n"
    "    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n"
    "    denom = PI * denom * denom;\n"
    "\n"
    "    return nom / denom;\n"
    "}\n"
    "\n"
    "float GeometrySchlickGGX(float NdotV, float roughness) {\n"
    "    float r = (roughness + 1.0);\n"
    "    float k = (r*r) / 8.0;\n"
    "\n"
    "    float nom   = NdotV;\n"
    "    float denom = NdotV * (1.0 - k) + k;\n"
    "\n"
    "    return nom / denom;\n"
    "}\n"
    "\n"
    "float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n"
    "    float NdotV = max(dot(N, V), 0.0);\n"
    "    float NdotL = max(dot(N, L), 0.0);\n"
    "    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n"
    "    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n"
    "\n"
    "    return ggx1 * ggx2;\n"
    "}\n"
    "\n"
    "// --- Shadow mapping ---\n"
    "float calculateShadow(vec4 fragPosLightSpace) {\n"
    "    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\n"
    "    projCoords = projCoords * 0.5 + 0.5; // Transform to [0,1] range\n"
    "\n"
    "    float closestDepth = texture(uShadowMap, projCoords.xy).r;\n"
    "    float currentDepth = projCoords.z;\n"
    "\n"
    "    float shadow = currentDepth > closestDepth ? 1.0 : 0.0; // Basic hard shadow\n"
    "\n"
    "    if (projCoords.z > 1.0) shadow = 0.0; // Prevent over-shadowing\n"
    "\n"
    "    return shadow;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "    vec3 N = getNormal();\n"
    "    vec3 V = normalize(uViewPos - fs_in.FragPos);\n"
    "    vec3 L = normalize(-uLightDir); // Light direction is from light to fragment\n"
    "\n"
    "    vec3 F0 = vec3(0.04);\n"
    "    F0 = mix(F0, uAlbedo, uMetallic);\n"
    "\n"
    "    // Calculate shadow\n"
    "    // vec4 fragPosLightSpace = uLightSpaceMatrix * vec4(fs_in.FragPos, 1.0);\n"
    "    // float shadow = calculateShadow(fragPosLightSpace);\n"
    "    float shadow = 0.0; // Temporarily disable shadows\n"
    "\n"
    "    // Reflectance equation\n"
    "    vec3 Lo = vec3(0.0);\n"
    "    // Only one light for now\n"
    "    {\n"
    "        // Calculate per-light radiance\n"
    "        vec3 radiance = uLightColor;\n"
    "\n"
    "        // Cook-Torrance BRDF\n"
    "        vec3 H = normalize(V + L);\n"
    "        float NdotL = max(dot(N, L), 0.0);\n"
    "        float NdotV = max(dot(N, V), 0.0);\n"
    "\n"
    "        float NDF = DistributionGGX(N, H, uRoughness);\n"
    "        float G   = GeometrySchlickGGX(NdotV, uRoughness);\n"
    "        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);\n"
    "\n"
    "        vec3 kS = F;\n"
    "        vec3 kD = vec3(1.0) - kS;\n"
    "        kD *= 1.0 - uMetallic;\n"
    "\n"
    "        vec3 numerator   = NDF * G * F;\n"
    "        float denominator = 4.0 * NdotV * NdotL + 0.001; // Add 0.001 to prevent divide by zero\n"
    "        vec3 specular = numerator / denominator;\n"
    "\n"
    "        // Add anti-aliasing to specular?\n"
    "        // float smoothness = 1.0 - uRoughness;\n"
    "        // specular *= smoothness * smoothness;\n"
    "\n"
    "        float NdotL_clamped = max(NdotL, 0.0);\n"
    "        Lo += (kD * uAlbedo / PI + specular) * radiance * NdotL_clamped * (1.0 - shadow);\n"
    "    }\n"
    "\n"
    "    // Ambient lighting (simple for now)\n"
    "    vec3 ambient = vec3(0.03) * uAlbedo * uAO; // Basic ambient term\n"
    "\n"
    "    vec3 color = ambient + Lo;\n"
    "\n"
    "    // HDR tonemapping\n"
    "    color = color / (color + vec3(1.0));\n"
    "    // Gamma correction\n"
    "    color = pow(color, vec3(1.0/2.2));\n"
    "\n"
    "    FragColor = vec4(color, 1.0);\n"
    "}\n";

const char* SHADER_SHADOW_VERT =
    "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "\n"
    "uniform mat4 uLightSpaceMatrix;\n"
    "uniform mat4 uModel;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    gl_Position = uLightSpaceMatrix * uModel * vec4(aPos, 1.0);\n"
    "}\n";

const char* SHADER_SHADOW_FRAG =
    "#version 330 core\n"
    "void main()\n"
    "{\n"
    "    // gl_FragDepth = gl_FragCoord.z; // Already done by default\n"
    "}\n";

const char* SHADER_QUAD_VERT =
    "#version 330 core\n"
    "layout (location = 0) in vec2 aPos;\n"
    "layout (location = 1) in vec2 aTexCoords;\n"
    "\n"
    "out vec2 TexCoords;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    TexCoords = aTexCoords;\n"
    "    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);\n"
    "}\n";

const char* SHADER_SSAO_FRAG =
    "#version 330 core\n"
    "out float FragColor;\n"
    "\n"
    "in vec2 TexCoords;\n"
    "\n"
    "uniform sampler2D uDepthTexture;\n"
    "uniform sampler2D uNoiseTexture;\n"
    "\n"
    "uniform vec3 uSamples[64];\n"
    "uniform mat4 uProjection;\n"
    "uniform float uRadius;\n"
    "uniform float uBias;\n"
    "uniform vec2 uNoiseScale;\n"
    "\n"
    "// Reconstruct view-space position from depth\n"
    "vec3 reconstructPosition(float depth, vec2 uv) {\n"
    "    float z = depth * 2.0 - 1.0; // Back to NDC\n"
    "    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);\n"
    "    vec4 viewSpacePosition = inverse(uProjection) * clipSpacePosition;\n"
    "    viewSpacePosition /= viewSpacePosition.w;\n"
    "    return viewSpacePosition.xyz;\n"
    "}\n"
    "\n"
    "// Get normal from depth texture (approximation)\n"
    "vec3 getNormalFromDepth(vec2 uv) {\n"
    "    vec3 p = reconstructPosition(texture(uDepthTexture, uv).r, uv);\n"
    "    // Sample neighbors\n"
    "    vec3 p_dx = reconstructPosition(texture(uDepthTexture, uv + vec2(1.0/1280.0, 0.0)).r, uv + vec2(1.0/1280.0, 0.0));\n"
    "    vec3 p_dy = reconstructPosition(texture(uDepthTexture, uv + vec2(0.0, 1.0/720.0)).r, uv + vec2(0.0, 1.0/720.0));\n"
    "    return normalize(cross(p_dx - p, p_dy - p));\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "    float depth = texture(uDepthTexture, TexCoords).r;\n"
    "    vec3 fragPos = reconstructPosition(depth, TexCoords);\n"
    "    vec3 normal = getNormalFromDepth(TexCoords);\n"
    "    // Sample random rotation from noise texture\n"
    "    vec3 randomVec = texture(uNoiseTexture, TexCoords * uNoiseScale).xyz;\n"
    "\n"
    "    // Create TBN matrix\n"
    "    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n"
    "    vec3 bitangent = cross(normal, tangent);\n"
    "    mat3 TBN = mat3(tangent, bitangent, normal);\n"
    "\n"
    "    float occlusion = 0.0;\n"
    "    int kernelSize = 64; // Should be passed as uniform\n"
    "    for(int i = 0; i < kernelSize; ++i)\n"
    "    {\n"
    "        // Get sample position: transform sample from tangent to view space\n"
    "        vec3 samplePos = TBN * uSamples[i]; \n"
    "        samplePos = fragPos + samplePos * uRadius;\n"
    "\n"
    "        // Get sample depth\n"
    "        vec4 offset = uProjection * vec4(samplePos, 1.0);\n"
    "        offset.xyz /= offset.w;\n"
    "        offset.xy = offset.xy * 0.5 + 0.5; // NDC to UV\n"
    "\n"
    "        float sampleDepth = texture(uDepthTexture, offset.xy).r;\n"
    "        vec3 sampleFragPos = reconstructPosition(sampleDepth, offset.xy);\n"
    "\n"
    "        float rangeCheck = abs(fragPos.z - sampleFragPos.z) < uRadius ? 1.0 : 0.0;\n"
    "        occlusion += (sampleDepth >= samplePos.z + uBias ? 1.0 : 0.0) * rangeCheck;\n"
    "    }\n"
    "    occlusion = 1.0 - (occlusion / kernelSize);\n"
    "\n"
    "    FragColor = occlusion;\n"
    "}\n";

const char* SHADER_SSAO_COMPOSITE_FRAG =
    "#version 330 core\n"
    "out vec4 FragColor;\n"
    "\n"
    "in vec2 TexCoords;\n"
    "\n"
    "uniform sampler2D uSceneTexture;\n"
    "uniform sampler2D uSSAOTexture;\n"
    "uniform float uSSAOStrength;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    vec3 sceneColor = texture(uSceneTexture, TexCoords).rgb;\n"
    "    float ssao = texture(uSSAOTexture, TexCoords).r;\n"
    "    FragColor = vec4(sceneColor * mix(1.0, ssao, uSSAOStrength), 1.0);\n"
    "}\n";

const char* SHADER_POSTPROCESS_FRAG =
    "#version 330 core\n"
    "out vec4 FragColor;\n"
    "\n"
    "in vec2 TexCoords;\n"
    "\n"
    "uniform sampler2D uSceneTexture;\n"
    "uniform float uExposure;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    vec3 hdrColor = texture(uSceneTexture, TexCoords).rgb;\n"
    "\n"
    "    // Tone mapping (Reinhard)\n"
    "    hdrColor = hdrColor / (hdrColor + vec3(1.0));\n"
    "    // Exposure control\n"
    "    hdrColor = vec3(1.0) - exp(-hdrColor * uExposure);\n"
    "\n"
    "    // Gamma correction\n"
    "    hdrColor = pow(hdrColor, vec3(1.0 / 2.2));\n"
    "\n"
    "    FragColor = vec4(hdrColor, 1.0);\n"
    "}\n";
